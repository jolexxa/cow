// ignore_for_file: non_constant_identifier_names
// ignore_for_file: camel_case_types
// ignore_for_file: public_member_api_docs
// ignore_for_file: constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for CowMLX (MLX Swift inference).
class CowMlxBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
  _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  CowMlxBindings(ffi.DynamicLibrary dynamicLibrary)
    : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  CowMlxBindings.fromLookup(
    ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup,
  ) : _lookup = lookup;

  /// Get the last error message for the calling thread.
  /// Returns NULL if no error. The returned pointer is valid until the next
  /// cow_mlx call on the same thread.
  ffi.Pointer<ffi.Char> cow_mlx_get_error() {
    return _cow_mlx_get_error();
  }

  late final _cow_mlx_get_errorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
        'cow_mlx_get_error',
      );
  late final _cow_mlx_get_error = _cow_mlx_get_errorPtr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Initialize the MLX backend. Call once before any other calls.
  /// Returns true on success.
  bool cow_mlx_init() {
    return _cow_mlx_init();
  }

  late final _cow_mlx_initPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('cow_mlx_init');
  late final _cow_mlx_init = _cow_mlx_initPtr.asFunction<bool Function()>();

  /// Shut down the MLX backend. Call once at program exit.
  void cow_mlx_shutdown() {
    return _cow_mlx_shutdown();
  }

  late final _cow_mlx_shutdownPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('cow_mlx_shutdown');
  late final _cow_mlx_shutdown = _cow_mlx_shutdownPtr
      .asFunction<void Function()>();

  /// Load a model from a local HuggingFace-format directory.
  /// The directory should contain config.json, tokenizer.json, and
  /// .safetensors weight files (standard mlx-community format).
  ///
  /// @param model_path Absolute path to the model directory.
  /// @param progress_cb Optional progress callback (may be NULL).
  /// @param user_data Opaque pointer forwarded to progress_cb.
  /// @return Model handle, or COW_MLX_INVALID_HANDLE on failure.
  int cow_mlx_load_model(
    ffi.Pointer<ffi.Char> model_path,
    cow_mlx_progress_fn progress_cb,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _cow_mlx_load_model(model_path, progress_cb, user_data);
  }

  late final _cow_mlx_load_modelPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int32 Function(
            ffi.Pointer<ffi.Char>,
            cow_mlx_progress_fn,
            ffi.Pointer<ffi.Void>,
          )
        >
      >('cow_mlx_load_model');
  late final _cow_mlx_load_model = _cow_mlx_load_modelPtr
      .asFunction<
        int Function(
          ffi.Pointer<ffi.Char>,
          cow_mlx_progress_fn,
          ffi.Pointer<ffi.Void>,
        )
      >();

  /// Free a loaded model. Invalidates the handle.
  void cow_mlx_free_model(int model) {
    return _cow_mlx_free_model(model);
  }

  late final _cow_mlx_free_modelPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
        'cow_mlx_free_model',
      );
  late final _cow_mlx_free_model = _cow_mlx_free_modelPtr
      .asFunction<void Function(int)>();

  /// Get a shareable integer ID for a model handle.
  /// This ID can be sent to another Dart isolate and used with
  /// cow_mlx_model_from_id to reconstruct the handle.
  int cow_mlx_model_get_id(int model) {
    return _cow_mlx_model_get_id(model);
  }

  late final _cow_mlx_model_get_idPtr =
      _lookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Int32)>>(
        'cow_mlx_model_get_id',
      );
  late final _cow_mlx_model_get_id = _cow_mlx_model_get_idPtr
      .asFunction<int Function(int)>();

  /// Reconstruct a model handle from an ID obtained via cow_mlx_model_get_id.
  /// The model must still be alive (not freed).
  /// Returns COW_MLX_INVALID_HANDLE if the ID is unknown.
  int cow_mlx_model_from_id(int model_id) {
    return _cow_mlx_model_from_id(model_id);
  }

  late final _cow_mlx_model_from_idPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int64)>>(
        'cow_mlx_model_from_id',
      );
  late final _cow_mlx_model_from_id = _cow_mlx_model_from_idPtr
      .asFunction<int Function(int)>();

  /// Create an inference context for a model.
  /// @param model Model handle.
  /// @param max_tokens Maximum context window size (0 = model default).
  /// @return Context handle, or COW_MLX_INVALID_HANDLE on failure.
  int cow_mlx_create_context(int model, int max_tokens) {
    return _cow_mlx_create_context(model, max_tokens);
  }

  late final _cow_mlx_create_contextPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32, ffi.Int32)>>(
        'cow_mlx_create_context',
      );
  late final _cow_mlx_create_context = _cow_mlx_create_contextPtr
      .asFunction<int Function(int, int)>();

  /// Free a context. Invalidates the handle.
  void cow_mlx_free_context(int context) {
    return _cow_mlx_free_context(context);
  }

  late final _cow_mlx_free_contextPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
        'cow_mlx_free_context',
      );
  late final _cow_mlx_free_context = _cow_mlx_free_contextPtr
      .asFunction<void Function(int)>();

  /// Reset context state (clears iterator, detokenizer, and stop tokens).
  /// @return true on success.
  bool cow_mlx_reset_context(int context) {
    return _cow_mlx_reset_context(context);
  }

  late final _cow_mlx_reset_contextPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Int32)>>(
        'cow_mlx_reset_context',
      );
  late final _cow_mlx_reset_context = _cow_mlx_reset_contextPtr
      .asFunction<bool Function(int)>();

  /// Tokenize text into token IDs.
  /// @param model Model handle.
  /// @param text UTF-8 text to tokenize.
  /// @param text_len Length of text in bytes.
  /// @param out_tokens Caller-allocated output buffer (may be NULL to query size).
  /// @param max_tokens Size of out_tokens buffer.
  /// @param add_special Whether to add BOS/EOS special tokens.
  /// @return Number of tokens produced. Negative if buffer too small
  /// (absolute value = required size). -1 on error.
  int cow_mlx_tokenize(
    int model,
    ffi.Pointer<ffi.Char> text,
    int text_len,
    ffi.Pointer<ffi.Int32> out_tokens,
    int max_tokens,
    bool add_special,
  ) {
    return _cow_mlx_tokenize(
      model,
      text,
      text_len,
      out_tokens,
      max_tokens,
      add_special,
    );
  }

  late final _cow_mlx_tokenizePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int32 Function(
            ffi.Int32,
            ffi.Pointer<ffi.Char>,
            ffi.Int32,
            ffi.Pointer<ffi.Int32>,
            ffi.Int32,
            ffi.Bool,
          )
        >
      >('cow_mlx_tokenize');
  late final _cow_mlx_tokenize = _cow_mlx_tokenizePtr
      .asFunction<
        int Function(
          int,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Int32>,
          int,
          bool,
        )
      >();

  /// Check if a token is an end-of-generation token.
  bool cow_mlx_is_eog(int model, int token) {
    return _cow_mlx_is_eog(model, token);
  }

  late final _cow_mlx_is_eogPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Int32, ffi.Int32)>>(
        'cow_mlx_is_eog',
      );
  late final _cow_mlx_is_eog = _cow_mlx_is_eogPtr
      .asFunction<bool Function(int, int)>();

  /// Begin a generation session. Processes the prompt tokens through
  /// the model (prefill) and prepares for token-by-token generation.
  ///
  /// Internally creates a TokenIterator (from MLXLMCommon) which handles
  /// prefill, KV cache management, and asyncEval GPU pipelining.
  ///
  /// Sampling parameters are passed as individual arguments:
  /// @param context Context handle.
  /// @param tokens Array of prompt token IDs.
  /// @param token_count Number of prompt tokens.
  /// @param temperature Sampling temperature (0.0 = greedy).
  /// @param top_p Top-P nucleus sampling (1.0 = disabled).
  /// @param top_k Top-K filtering (0 = disabled).
  /// @param min_p Min-P filtering (0.0 = disabled).
  /// @param repeat_penalty Repetition penalty (1.0 = disabled).
  /// @param repeat_window Number of recent tokens for repetition penalty.
  /// @param seed RNG seed (0 = random).
  /// @return true on success.
  bool cow_mlx_generate_begin(
    int context,
    ffi.Pointer<ffi.Int32> tokens,
    int token_count,
    double temperature,
    double top_p,
    int top_k,
    double min_p,
    double repeat_penalty,
    int repeat_window,
    int seed,
  ) {
    return _cow_mlx_generate_begin(
      context,
      tokens,
      token_count,
      temperature,
      top_p,
      top_k,
      min_p,
      repeat_penalty,
      repeat_window,
      seed,
    );
  }

  late final _cow_mlx_generate_beginPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Int32,
            ffi.Pointer<ffi.Int32>,
            ffi.Int32,
            ffi.Float,
            ffi.Float,
            ffi.Int32,
            ffi.Float,
            ffi.Float,
            ffi.Int32,
            ffi.Int32,
          )
        >
      >('cow_mlx_generate_begin');
  late final _cow_mlx_generate_begin = _cow_mlx_generate_beginPtr
      .asFunction<
        bool Function(
          int,
          ffi.Pointer<ffi.Int32>,
          int,
          double,
          double,
          int,
          double,
          double,
          int,
          int,
        )
      >();

  /// Generate the next text chunk.
  ///
  /// Advances the TokenIterator by one token, feeds it through the
  /// streaming detokenizer, and writes any complete UTF-8 text to buf.
  ///
  /// @param context Context handle.
  /// @param buf Caller-allocated output buffer (may be NULL to query size).
  /// @param buf_len Size of buf.
  /// @return Number of UTF-8 bytes written.
  /// 0 if the token produced an incomplete character (e.g. partial emoji).
  /// -1 if generation is done (EOG token or max tokens reached).
  /// Negative (< -1) if buffer too small (absolute value = required size).
  int cow_mlx_generate_next(
    int context,
    ffi.Pointer<ffi.Char> buf,
    int buf_len,
  ) {
    return _cow_mlx_generate_next(context, buf, buf_len);
  }

  late final _cow_mlx_generate_nextPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int32, ffi.Pointer<ffi.Char>, ffi.Int32)
        >
      >('cow_mlx_generate_next');
  late final _cow_mlx_generate_next = _cow_mlx_generate_nextPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  /// Get the number of tokens currently in the KV cache.
  int cow_mlx_cache_token_count(int context) {
    return _cow_mlx_cache_token_count(context);
  }

  late final _cow_mlx_cache_token_countPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
        'cow_mlx_cache_token_count',
      );
  late final _cow_mlx_cache_token_count = _cow_mlx_cache_token_countPtr
      .asFunction<int Function(int)>();

  /// Trim n tokens from the END of the KV cache.
  int cow_mlx_cache_trim_end(int context, int n) {
    return _cow_mlx_cache_trim_end(context, n);
  }

  late final _cow_mlx_cache_trim_endPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32, ffi.Int32)>>(
        'cow_mlx_cache_trim_end',
      );
  late final _cow_mlx_cache_trim_end = _cow_mlx_cache_trim_endPtr
      .asFunction<int Function(int, int)>();

  /// Trim n tokens from the FRONT of the KV cache.
  int cow_mlx_cache_trim_front(int context, int n) {
    return _cow_mlx_cache_trim_front(context, n);
  }

  late final _cow_mlx_cache_trim_frontPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32, ffi.Int32)>>(
        'cow_mlx_cache_trim_front',
      );
  late final _cow_mlx_cache_trim_front = _cow_mlx_cache_trim_frontPtr
      .asFunction<int Function(int, int)>();
}

typedef cow_mlx_progress_fnFunction =
    ffi.Bool Function(ffi.Float progress, ffi.Pointer<ffi.Void> user_data);
typedef Dartcow_mlx_progress_fnFunction =
    bool Function(double progress, ffi.Pointer<ffi.Void> user_data);

/// Progress callback for model loading.
/// @param progress Fraction complete, 0.0 to 1.0.
/// @param user_data Opaque pointer passed through from cow_mlx_load_model.
/// @return true to continue loading, false to cancel.
typedef cow_mlx_progress_fn =
    ffi.Pointer<ffi.NativeFunction<cow_mlx_progress_fnFunction>>;

const int COW_MLX_INVALID_HANDLE = -1;
